#!/usr/bin/env python
import os
import re
import sys

import yaml
import scipy

from copy import deepcopy

import networkx as nx
import matplotlib
import graphviz as gv
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
# from networkx.drawing.nx_pydot import read_dot
from networkx.drawing.nx_agraph import read_dot, write_dot, graphviz_layout

from networkx.drawing import nx_agraph

import pygraphviz

import MySQLdb


import warnings
warnings.simplefilter('ignore',scipy.sparse.SparseEfficiencyWarning)

ARCS = 'ARCS.CSV'
VERTS = 'VERTICES.CSV'
AG_DOT = 'AttackGraph.dot'

exploitDict = {}
conf_override = {}
coalesced_rules = [ ]
exploit_rules = { }

class AttackGraph(nx.MultiDiGraph):
    """
    Class for working with MulVal Attack Graphs.
    """

    def __init__(self, data=None, name='', inputDir='/tmp', file=None, **attr):
        self.data = read_dot(os.path.join(inputDir, AG_DOT))
        super(AttackGraph, self).__init__(self.data)
        # print(self.nodes())

        with open('scoreDict.yml') as f:
            # print(f.readlines())
            self.conf_override = yaml.safe_load(f)
            # print('conf_overrides', self.conf_override)
            self.coalesced_rules = self.conf_override['coalesce_rules']
            # print('coalesced rules loaded: ', self.coalesced_rules)
            self.exploit_rules = self.conf_override['exploit_rules']
            self.exploitDict = self.conf_override['exploitDict']

        # add fields not included in dot file
        self.__updateAG()

    # def plot1(self, **kwargs):
    #
    #     # labels = self.getPlotNodeLabels()
    #     # nodePos = nx.layout.spring_layout(self)
    #     nodePos = graphviz_layout(self, prog='dot')
    #
    #     nodeShapes = set((aShape[1]["s"] for aShape in self.nodes(data=True)))
    #     print(nodeShapes)
    #
    #     labels = self.nodes.keys()
    #     labels = None
    #
    #     # For each node class...
    #     for aShape in nodeShapes:
    #         # ...filter and draw the subset of nodes with the same symbol in the positions
    #         # that are now known through the use of the layout.
    #         nx.draw_networkx_nodes(self, nodePos, with_labels=True, font_weight='bold', labels=labels, node_shape=aShape, nodelist=[sNode[0] for sNode in
    #                                                                               filter(lambda x: x[1]["s"] == aShape,
    #                                                                                      self.nodes(data=True))])
    #
    #     # Finally, draw the edges between the nodes
    #     nx.draw_networkx_edges(self,  nodePos, with_labels=True, font_weight='bold',)
    #
    #     # nx.draw(self, with_labels=True, font_weight='bold', labels=None)
    #     plt.show()

    def plot2(self, **kwargs):
        if 'outfilename' in kwargs:
            outfilename = kwargs.get("outfilename")
        else:
            outfilename = 'test.png'

        A = nx.nx_agraph.to_agraph(self)
        A.layout('dot', args='-Nfontsize=10 -Nwidth=".2" -Nheight=".2" -Nmargin=0 -Gfontsize=8')
        A.draw(outfilename)
        plt.show()


    def __updateAG(self):
        for node in self.nodes.keys():
            if self.nodes[node]['shape'] == 'diamond':
                self.nodes[node]['type'] = 'OR'
                self.nodes[node]['color'] = 'blue'
                self.nodes[node]['s'] = 'd'
                self.nodes[node]['scores'] = []
            elif self.nodes[node]['shape'] == 'ellipse':
                self.nodes[node]['type'] = 'AND'
                self.nodes[node]['color'] = 'red'
                self.nodes[node]['s'] = 'o'
                self.nodes[node]['exploit_rule_score'] = None
            elif self.nodes[node]['shape'] == 'box':
                self.nodes[node]['type'] = 'LEAF'
                self.nodes[node]['color'] = 'green'
                self.nodes[node]['s'] = 's'
            else: print('Unknown node type: ', self.nodes[node]['shape'] )

    def getPlotNodeLabels(self):
        labels = {}
        colors = []

        for node in self.nodes.keys():
            labels[node]=  self.nodes[node]['label']

        return labels

    def getCVSSscore(self, cveid):
        score = 'null'  # the score to return
        con = None
        print('looking for cveid: ', cveid)

        if cveid in self.exploitDict.keys(): # check user overrides first
            score = self.exploitDict[cveid]
            # print('Matched hypothetical score ' + cveid + ' : ' + str(score))
        else:
            try:
                con = MySQLdb.connect('localhost', 'nvd', 'nvd', 'nvd')
                cur = con.cursor(MySQLdb.cursors.DictCursor)
                cur.execute("select score from nvd where id = '%s'" % (cveid))
                res = cur.fetchone()  # the cveid or None it
                if res:
                    score = res['score']
                    print('Found cveid ' + cveid + ' with score: ' + str(score))

                else:
                    print('bad cveid (result unknown): setting CVSS to 1!!!**** [' + cveid + ']')
                    score = 1
            except MySQLdb.Error as e:
                print("Error %d: %s" % (e.args[0], e.args[1]))
                sys.exit(1)

            finally:
                if con:
                    con.close()

        return score

    def getANDnodes(self):
        andNodes = [n for n,v in self.nodes(data=True) if v['type'] == 'AND']
        # print(andNodes)
        return andNodes

    def getORnodes(self):
        orNodes = [n for n,v in self.nodes(data=True) if v['type'] == 'OR']
        print(orNodes)
        return orNodes

    def getLEAFnodes(self):
        leafNodes = [n for n,v in self.nodes(data=True) if v['type'] == 'LEAF']
        print(leafNodes)
        return leafNodes

    def add_edge(self, u_for_edge, v_for_edge, key=None, **attr):

        u, v = u_for_edge, v_for_edge
        # add nodes
        if u not in self._succ:
            self._succ[u] = self.adjlist_inner_dict_factory()
            self._pred[u] = self.adjlist_inner_dict_factory()
            self._node[u] = self.node_attr_dict_factory()
        if v not in self._succ:
            self._succ[v] = self.adjlist_inner_dict_factory()
            self._pred[v] = self.adjlist_inner_dict_factory()
            self._node[v] = self.node_attr_dict_factory()
        if key is None:
            key = self.new_edge_key(u, v)
            print('******MAKING KEY *****', u, v, key, attr)
        if v in self._succ[u]:
            keydict = self._adj[u][v]
            datadict = keydict.get(key, self.edge_key_dict_factory())
            datadict.update(attr)
            keydict[key] = datadict
        else:
            # selfloops work this way without special treatment
            datadict = self.edge_attr_dict_factory()
            datadict.update(attr)
            keydict = self.edge_key_dict_factory()
            keydict[key] = datadict
            self._succ[u][v] = keydict
            self._pred[v][u] = keydict
        print('*****SETTING KEY FOR EDGE*****', self.edges(u,v))
        # e = self.edges[((u,v))]
        # print(e)

        return key

    def setANDscores(self):

        andNodes = self.getANDnodes()
        for andNode in andNodes:
            # set if we are explicit coalesce rule
            # print('Checking: ', self.nodes[andNode]['label'], self.coalesced_rules)
            if any(cr in self.nodes[andNode]['label'] for cr in self.coalesced_rules):
                self.nodes[andNode]['toCoalesce'] = True
                print('setting node to coalesce: ', self.nodes[andNode])

            # set if there is a general exploit_rule score
            elif any(xr in self.nodes[andNode]['label'] for xr in self.exploit_rules.keys()):
                self.nodes[andNode]['toCoalesce'] = False
                # print('setting node to default exploit score: ', self.nodes[andNode])
                for xr in self.exploit_rules.keys():
                    if xr in self.nodes[andNode]['label']:
                        self.nodes[andNode]['exploit_rule_score'] = self.exploit_rules[xr]
                        # print('setting node to default exploit score: ', self.nodes[andNode])

                # look for cvss score in leafs
                leafPreds = [n for n in self.predecessors(andNode) if self.nodes[n]['type'] == 'LEAF']
                score = None
                for p in leafPreds:
                    matchObj = re.match(r'.*:vulExists\((.*),(.*),(.*),(.*),(.*)\):.*', self.nodes[p]['label'], re.M | re.I)
                    # print('looking for cve id in: ', self.nodes[p]['label'], matchObj)
                    # assuming only 1 vuln per AND...
                    if matchObj:
                        mycveid = matchObj.group(2).strip('\'')
                        # print('finding score for cveid: ', mycveid)
                        score = self.getCVSSscore(mycveid)
                        # self.nodes[andNode]['scores'].append(self.nodes[p]['exploit_rule_score'])

                if score:
                    print('score found, overwriting default for node: ', score, self.nodes[andNode]['exploit_rule_score'], andNode)
                    self.nodes[andNode]['exploit_rule_score'] = score
                else:
                    print('no score found, preserving default', self.nodes[andNode])



    def scoreANDs(self):
        andNodes = self.getANDnodes()
        print('scoreANDs remaining AND nodes: ', andNodes)
        for a in andNodes:
            print(self.nodes[a])
            i_edges = [(u, v, k, e) for u, v, k, e in self.in_edges(a, keys=True, data=True)]
            o_edges = [((u, v), e) for u, v, e in self.out_edges(a,data=True)]
            print('a in out: ', a, i_edges, o_edges)
            # for (u1, v1), (u2, v2) in zip(i_edges, o_edges):
            if not i_edges or not o_edges:  # we're at root
                if not i_edges and not o_edges:
                    print('scoreANDs !!!!!!!!!! Isolated Node !!!!!!!!!!!!!!')
                if not i_edges:
                    for ((u2, v2), e2) in o_edges:
                        print('u2, v2, e2: ', u2, v2, e2)
                        self.nodes[v2]['scores'].append(self.nodes[a]['exploit_rule_score'])
                        print('added score to child OR node: ', self.nodes[v2])
                        # print('making new edge: ', (u1, v2))
                        self.remove_edge(u2, v2, *e2)
                        o_edges.remove(((u2, v2), e2))
                if not o_edges:
                    for ((u1, v1), e1) in i_edges:
                        print('u1, v1, e1: ', u1, v1, e1)
                        self.remove_edge(u1, v1, *e1)
                        i_edges.remove(((u1, v1), e1))

            else:
                for ((u1, v1), e1) in i_edges:
                    print('scoreANDs u1, v1, e1: ', u1, v1, e1)
                    for ((u2, v2), e2) in  o_edges:
                        print('u2, v2, e2: ', u2, v2, e2)

                        if self.nodes[v2]['type'] != 'OR':
                            print('not an OR node... something bad happened...')

                        self.nodes[v2]['scores'].append(self.nodes[a]['exploit_rule_score'])
                        print('added score to child OR node: ', self.nodes[v2])
                        print('making new edge: ', (u1, v2))
                        if not v1: # we're a root
                            # print('Were at root, no u1 v2 edge: ', (u1, v2))
                            # self.add_edge(u1, v2)
                            # self.remove_edge(u1, v1)
                            # i_edges.remove((u1, v1))
                            self.remove_edge(u2, v2, *e2)
                            o_edges.remove(((u2, v2), e2))
                        elif not u2: # we're a sink
                            # print('Were at root, no u1 v2 edge: ', (u1, v2))
                            # self.add_edge(u1, v2)
                            # self.remove_edge(u1, v1)
                            # i_edges.remove((u1, v1))
                            self.remove_edge(u1, v1, *e1)
                            o_edges.remove(((u1, v1), e1))
                        elif v1 == u2:
                            print('making new edge: ', (u1, v2))
                            self.add_edge(u1, v2)
                            self.remove_edge(u1, v1, *e1)
                            i_edges.remove(((u1, v1), e1))
                            self.remove_edge(u2, v2, *e2)
                            o_edges.remove(((u2, v2), e2))
                        else: print('ScoreANDs***** I Shouldnt be here *********')
                         # self.remove_node(a)


            # for (u1, v1), (u2, v2) in zip(i_edges, o_edges):
            #     print('making new edge: ', (u1, v2))
            #     self.add_edge(u1, v2)


    def coalesceANDnodes(self):
        andNodes = [n for n in self.nodes() if self.nodes[n]['type'] == 'AND' and self.nodes[n]['toCoalesce']]
        print('andNodes to coalesce: ', andNodes)

        for a in andNodes:
            i_edges = [((u, v), e) for u, v, e in self.in_edges(a, data=True)]
            o_edges = [((u, v) , e)for u, v, e in self.out_edges(a,data=True)]
            print('a in out: ', a, i_edges, o_edges)
            # for (u1, v1), (u2, v2) in zip(i_edges, o_edges):
            if not i_edges or not o_edges:  # we're at root
                if not i_edges and not o_edges:
                    print('coalesceANDnodes !!!!!!!!!! Isolated Node !!!!!!!!!!!!!!')
                if not i_edges:
                    for ((u2, v2), e2) in o_edges:
                        print('u2, v2, e2: ', u2, v2, e2)
                        self.remove_edge(u2, v2, *e2)
                        o_edges.remove(((u2, v2), e2))
                if not o_edges:
                    for ((u1, v1), e1) in i_edges:
                        print('u1, v1, e1: ', u1, v1, e1)
                        self.remove_edge(u1, v1, *e1)
                        i_edges.remove(((u1, v1), e1))

            else:
                for ((u1, v1), e1) in i_edges:
                    print('u1, v1, e1: ', u1, v1, e1)
                    for ((u2, v2), e2) in  o_edges:
                        print('u2, v2, e2: ', u2, v2, e2)
                        if v1 == u2:
                            print('making new edge: ', (u1, v2))
                            self.add_edge(u1, v2)
                            self.remove_edge(u1, v1, *e1)
                            i_edges.remove(((u1, v1), e1))
                            self.remove_edge(u2, v2, *e2)
                            o_edges.remove(((u2, v2), e2))
                print('i+o edges: ', i_edges, o_edges, i_edges + o_edges)


    def coalesceORnodes(self):
        orNodes = [n for n in self.nodes() if self.nodes[n]['type'] == 'OR' and len(self.nodes[n]['scores']) == 0 ]
        while len(orNodes) > 0:

            print(self.getORnodes())
            print(orNodes)
            for o in orNodes:
                print(self.nodes[o])
                i_edges = [((u, v), e) for u, v, e in self.in_edges(o, data=True)]
                o_edges = [((u, v), e) for u, v, e in self.out_edges(o, data=True)]
                print('coalesceORnodes o in out: ', o, i_edges, o_edges)

                if not i_edges or not o_edges:  # we're at root
                    if not i_edges and not o_edges:
                        print('coalesceORnodes !!!!!!!!!! Isolated Node !!!!!!!!!!!!!!')
                    if not i_edges:
                        for ((u2, v2), e2) in o_edges:
                            print('u2, v2 e2: ', u2, v2, e2)
                            self.remove_edge(u2, v2, *e2)
                            o_edges.remove(((u2, v2), e2))
                            # self.remove_nodes_from(list(nx.isolates(self)))
                            # i_edges = [(u, v) for u, v, e in self.in_edges(o, data=True)]
                            # o_edges = [(u, v) for u, v, e in self.out_edges(o, data=True)]
                    if not o_edges:
                        for ((u1, v1), e1) in i_edges:
                            print('u1, v1 e1: ', u1, v1, e1)
                            self.remove_edge((u1, v1), e1)
                            i_edges.remove(((u1, v1), e1))
                            # self.remove_nodes_from(list(nx.isolates(self)))
                            # i_edges = [(u, v) for u, v, e in self.in_edges(o, data=True)]


                else:
                    for ((u1, v1), e1) in i_edges:
                        print('u1, v1 e1: ', u1, v1, *e1)
                        for ((u2, v2), e2) in  o_edges:
                            print('u2, v2 e2: ', u2, v2, e2)
                            if v1 == u2:
                                print('coalesceORnodes making new edge: ', (u1, v2), e1)

                                self.remove_edge(u1, v1, *e1)
                                i_edges.remove(((u1,v1), e1))
                                self.add_edge(u1, v2)
                                if not i_edges:
                                    self.remove_edge(u2,v2, *e2)
                                    o_edges.remove(((u2,v2), e2))
                    print('coalesceORnodes i+o edges: ', i_edges, o_edges, i_edges + o_edges)
                # for e in i_edges + o_edges:
                # print('try to remove edge e from graph: ', e)
                # self.remove_edge(*e)
                # self.remove_node(o)  # removes all edges duh :|
            self.remove_nodes_from(list(nx.isolates(self)))
            orNodes = [n for n in self.nodes() if self.nodes[n]['type'] == 'OR' and len(self.nodes[n]['scores']) == 0 ]
            print('coalesceORnodes ', self.getORnodes())
            print(orNodes)
            for o in orNodes:
                print(self.nodes[o])

        # print('andNodes to coalesce: ', andNodes)
        #
        # for a in andNodes:
        #     i_edges = [(u, v) for u, v, e in self.in_edges(a, data=True)]
        #     o_edges = [(u, v) for u, v, e in self.out_edges(a, data=True)]
        #     print('a in out: ', a, i_edges, o_edges)
        #     for (u1, v1), (u2, v2) in zip(i_edges, o_edges):
        #         print('making new edge: ', (u1, v2))
        #         self.add_edge(u1, v2)
        #     print('i+o edges: ', i_edges, o_edges, i_edges + o_edges)
        #     # for e in i_edges + o_edges:
        #     # print('try to remove edge e from graph: ', e)
        #     # self.remove_edge(*e)
        #     self.remove_node(a)  # removes all edges duh :|


    # def setORscore(self, orNode):
    #     # look for AND node scores in preds
    #     leafPreds = [n for n in self.predecessors(andNode) if self.nodes[n]['type'] == 'LEAF']
    #     score = None
    #     for p in leafPreds:
    #         matchObj = re.match(r'.*:vulExists\((.*),(.*),(.*),(.*),(.*)\):.*', self.nodes[p]['label'],
    #                             re.M | re.I)
    #         # print('looking for cve id in: ', self.nodes[p]['label'], matchObj)
    #         # assuming only 1 vuln per AND...
    #         if matchObj:
    #             mycveid = matchObj.group(2).strip('\'')
    #             # print('finding score for cveid: ', mycveid)
    #             score = self.getCVSSscore(mycveid)
    #     if score:
    #         # print('score found, overwriting default for node: ', score, self.nodes[andNode]['exploit_rule_score'], andNode)
    #         self.nodes[andNode]['exploit_rule_score'] = score
        # else:
        # print('no score found, preserving default', self.nodes[andNode])

    def pruneLEAFS(self):
        leafs = self.getLEAFnodes()
        self.remove_nodes_from(leafs)

    def getTransMatrix(self, tgraph):
        # tgraph = deepcopy(self)
        tgraph = tgraph
        tmatrix = nx.adjacency_matrix(tgraph)
        # print(tmatrix)
        # print(tmatrix.todense())
        # print(type(tmatrix))
        # tmatrix.setdiag(1)
        # print(tmatrix.todense())


        # 1. set AND node exploit score
        #    either default value of AND text or CVSS lookup
        tgraph.setANDscores()
        tgraph.plot2(outfilename=self.name + '_001_setANDscores.png')

        # 2. remove LEAF nodes after scores applied
        tgraph.pruneLEAFS()
        print('Removing dead nodes: ', list(nx.isolates(tgraph)))
        tgraph.remove_nodes_from(list(nx.isolates(tgraph)))
        tgraph.plot2(outfilename=self.name + '_002_pruneLEAFs.png')


        # 3. Join edges passing through this and (multi-hop, no exploit)
        tgraph.coalesceANDnodes()
        print('Removing dead nodes: ', list(nx.isolates(tgraph)))
        tgraph.remove_nodes_from(list(nx.isolates(tgraph)))
        tgraph.plot2(outfilename=self.name + '_003_coalesceANDs.png')

        # 4. push AND exploit_score down to child or score dicts
        tgraph.scoreANDs()
        print('Removing dead nodes: ', list(nx.isolates(tgraph)))
        tgraph.remove_nodes_from(list(nx.isolates(tgraph)))
        tgraph.plot2(outfilename=self.name + '_004_scoreANDs.png')


        # 5. remove or nodes with empty score dict
        tgraph.coalesceORnodes()
        print('Removing dead nodes: ', list(nx.isolates(tgraph)))
        tgraph.remove_nodes_from(list(nx.isolates(tgraph)))
        tgraph.plot2(outfilename=self.name + '_005_coalesceORs.png')

        for n in tgraph.nodes():
            print(tgraph.nodes[n])

        # orNodes = tgraph.getORnodes()
        # print('or nodes before: ', orNodes)
        # for n in orNodes:
        #     # print('set or node: ', n, type(n))
        #     tgraph.setORscore(n)
        #     print(tgraph.nodes[n])
        # print('or nodes after: ', orNodes)

        return tmatrix





if __name__ == '__main__':


    if len(sys.argv) != 4:
        print('<usage> genTransMatrix.py inputdir run_name')
        inputDir = os.getcwd()
        matrixFileName = 'a.csv'
        name = 'nameMe'
    else:
        # read inputDir/AttackGraph.dot
        inputDir = sys.argv[1]
        # write transMatrix.csv
        matrixFileName = sys.argv[2] + '.csv'
        name = sys.argv[2]



    A = AttackGraph(inputDir=inputDir)
    A.name = name

    A.plot2(outfilename=name + '_001_orig.png')
    tgraph = deepcopy(A)


    # make transition matrix
    # A.getANDnodes()
    # A.getORnodes()
    # A.getLEAFnodes()

    tmatrix = A.getTransMatrix(tgraph)






